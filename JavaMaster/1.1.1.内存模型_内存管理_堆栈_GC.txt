##并发编程模型的分类
- 在并发编程中，我们需要处理两个关键问题：线程之间如何通信及线程之间如何同步
- 通信是指线程之间以何种机制来交换信息。在命令式编程中，线程之间的通信机制有两种：共享内存和消息传递。
- -在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来隐式进行通信
- 在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信。
- 同步是指程序用于控制不同线程之间操作发生相对顺序的机制。在共享内存并发模型里，同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。在消息传递的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。<br>
    **Java的并发采用的是共享内存模型，Java线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。如果编写多线程程序的Java程序员不理解隐式进行的线程之间通信的工作机制，很可能会遇到各种奇怪的内存可见性问题。**<br>
参考文章：
##Java的内存模型
- 主内存和本地内存
- 它是Java线程之间通信的控制机制<br>
- JMM对Java程序作出保证——如果程序是正确同步的，程序的执行将具有顺序一致性。即，程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同
- 参考文章见《理解Java内存模型》
##JVM的内存管理
- JVM在执行java程序中会将它管理的内存分成5部分。有些随JVM启动而储存在，有些随着线程启动与结束
  1. 程序计数器
  `线程私有的一小块内存，可看作当前线程所执行的字节码的行号指示器。唯一一块没有OOM情况的区域。java中通过改变这个计数器的值来进行一些如分支，循环，异常处理，多线程时间片切换回当前线程的功能。<br>`
	`当执行的是java方法时，这个计数器的值当前字节码的行号；当执行native方法时为0`<br>
 2. Java虚拟机栈<br>
 `线程私有，生命周期与线程相同的一块内存`<br>
`描述的是Java方法的内存模型：每个方法执行的同时创建一个栈帧stack Frame,用于存局部变量表，操作数栈，动态链接，方法出口等信息。每个方法从调用至结束，相对着栈帧在JVM栈中从入栈到出栈`<br>
`局部变量表存放的是编译期可知的各种基本数据类型（如boolean，byte，char等），对象引用（reference类型）和returnAddress(指向一条字节码指令的地址)`
`其中long和double类型占两个局部变量空间，其余只占一个。局部变量空间在编译就能确定下来`
`两种异常状态：1.当线程请求的栈深度大于JVM所允许的栈深度时，抛出SOF异常；当虚拟机允许动态扩展时（当今大部分都支持），但是栈内存申请不到足够的内存时，就报出OOM异常。`
 3. 本地方法栈
 `与虚拟机栈功能基本差不多，区别在于本地方法栈为native方法服务，而虚拟机栈为Java方法服务`
`两种异常状态：与JVM栈一样`
 4. Java堆
 `线程共享，JVM内存管理中最大的一块内存，在JVM启动时创建:用于存放对象实例，几乎所有对象实例都在这里分配内存`
`GC管理的主要区域，被称为“GC堆”。堆中细分可分为新生代和老年代，再细分则为Eden空间，From Survior空间，To survior空间等。	` 
`从内存分配的角度看，线程共享的Java堆可能划分出多个线程私有的分配缓冲区TLAB。根据JVM规范，Java堆可以处于物理上不连续的内存上，只要逻辑上连续即可`
`堆的JVM参数  -Xms  -Xmx`
`当堆中没有内存完成实例分配时，就抛出OOM异常`
 5. 方法区
`方法区与Java堆一样，是各个线程共享的内存区域。用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。有个别名叫Non-Heap非堆`	 
##JVM中的堆和栈
##GC
